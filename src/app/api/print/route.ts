import { NextRequest, NextResponse } from 'next/server';

const DEBUG_MODE = process.env.DEBUG === 'true';
const ANDROID_SERVER = process.env.ANDROID_SERVER_URL || 
    (DEBUG_MODE ? 'http://192.168.0.7:8080' : 'http://192.168.29.2:8080');
const COMPILATION_SERVER = process.env.COMPILATION_SERVER_URL || 
    (DEBUG_MODE ? 'http://localhost:3001' : 'http://192.168.29.3:3001');

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { team_id, jsonData, round = 0 } = body;
    
    console.log(`[PRINT API] Processing print request for team: ${team_id}, round: ${round}`);
    console.log(`[PRINT API] JSON data:`, jsonData);
    
    // Step 1: Execute interpreter with JSON data on compilation server
    console.log(`[PRINT API] Sending to compilation server: ${COMPILATION_SERVER}/execute`);
    const executeResponse = await fetch(`${COMPILATION_SERVER}/execute`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        teamId: team_id,
        jsonData: typeof jsonData === 'string' ? jsonData : JSON.stringify(jsonData),
        round: round
      }),
    });

    console.log(`[PRINT API] Compilation server response status: ${executeResponse.status}`);
    
    if (!executeResponse.ok) {
      const errorData = await executeResponse.json();
      console.error(`[PRINT API] Compilation server error:`, errorData);
      return NextResponse.json(
        { 
          error: 'Execution failed', 
          details: errorData.error || 'Unknown execution error'
        },
        { status: 400 }
      );
    }

    const executeResult = await executeResponse.json();
    console.log(`[PRINT API] Execution result:`, executeResult);
    
    if (!executeResult.success) {
      console.error(`[PRINT API] Execution not successful:`, executeResult.error);
      return NextResponse.json(
        { 
          error: 'Execution failed', 
          details: executeResult.error
        },
        { status: 400 }
      );
    }
    
    console.log(`[PRINT API] Commands generated: ${executeResult.commands?.length || 0}`);
    console.log(`[PRINT API] Commands:`, JSON.stringify(executeResult.commands));
    
    // Step 2: Try to send printer commands to Android server
    // If Android is offline, the compilation server already handled ASCII printing
    try {
      const printRequestBody = {
        team_id,
        round: round,
        commands: executeResult.commands,
        timestamp: Date.now()
      };
      console.log(`[PRINT API] Checking Android server availability...`);
      
      // First check if Android server is available with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
      
      const healthCheck = await fetch(`${ANDROID_SERVER}/health`, {
        method: 'GET',
        signal: controller.signal
      }).catch(() => null).finally(() => clearTimeout(timeoutId));
      
      if (!healthCheck || !healthCheck.ok) {
        console.log(`[PRINT API] Android server offline - ASCII receipt was generated by compilation server`);
        return NextResponse.json({
          success: true,
          message: 'Commands executed successfully (ASCII mode)',
          commands: executeResult.commands,
          commandCount: executeResult.commands?.length || 0
        });
      }
      
      console.log(`[PRINT API] Android server online - sending print commands`);
      console.log(`[PRINT API] Sending to Android server: ${ANDROID_SERVER}/api/print-commands`);
      console.log(`[PRINT API] Print request body:`, JSON.stringify(printRequestBody));
      
      const printResponse = await fetch(`${ANDROID_SERVER}/api/print-commands`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(printRequestBody),
      });

      console.log(`[PRINT API] Android server response status: ${printResponse.status}`);
      
      if (!printResponse.ok) {
        const errorText = await printResponse.text();
        console.error(`[PRINT API] Android server error: ${printResponse.status}`, errorText);
        // Even if Android fails, we generated commands successfully
        return NextResponse.json({
          success: true,
          message: 'Commands generated but print failed',
          commands: executeResult.commands,
          commandCount: executeResult.commands?.length || 0,
          printError: errorText
        });
      }

      const printResult = await printResponse.json();
      console.log(`[PRINT API] Print result:`, printResult);
      
      // Round tracking is now handled by the Android server directly in /api/print-commands
      // No need to call /api/track-round separately
      console.log(`[PRINT API] Round ${round} should be tracked by Android server`);
      
      return NextResponse.json(printResult);
    } catch (printError) {
      console.log(`[PRINT API] Android server unreachable - returning success with ASCII mode`);
      // Android server is offline, but compilation worked
      return NextResponse.json({
        success: true,
        message: 'Commands executed successfully (ASCII mode - Android offline)',
        commands: executeResult.commands,
        commandCount: executeResult.commands?.length || 0
      });
    }
  } catch (error) {
    console.error('Print proxy error:', error);
    return NextResponse.json(
      { error: 'Failed to process print request', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}